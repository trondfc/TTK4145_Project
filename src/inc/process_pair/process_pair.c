/**
 * @file process_pair.c
 * @brief library for process pair communication
 *         needs file "keyfile" in the same directory as the executable
 * @version 0.1
 * @date 2024-02-27
 * 
 * @copyright Copyright (c) 2024
 * 
 */
#include "process_pair.h"

/**
 * @brief start the system queue reset system
 * 
 * @param timeOutTimeS 
 */
void sysQueInit(int timeOutTimeS){
    queMsgData_t* data = (queMsgData_t*)malloc(sizeof(queMsgData_t));
    data->message = (queMsg_t*)malloc(sizeof(queMsg_t));
    data->buf = (struct msqid_ds*)malloc(sizeof(struct msqid_ds));
    data->sysQueTimeout = timeOutTimeS;
    data->sysQueMaster = false;
    data->queOutputMutex = (pthread_mutex_t*)malloc(sizeof(pthread_mutex_t));
    pthread_mutex_init(data->queOutputMutex, NULL);

    key_t key = ftok("keyfile", 65);
    if(PROSESS_PAIR_DEBUG)printf("key: %d\n", key);
    if(key == -1){
        perror("ftok");
        exit(EXIT_FAILURE);
    }

    data->msgid = msgget(key, IPC_CREAT | 0666);
    if(data->msgid == -1){
        perror("msgget readSysQue");
        exit(EXIT_FAILURE);
    }
    if(PROSESS_PAIR_DEBUG)printf("msgid: %d\n", data->msgid);
    msgctl(data->msgid, IPC_STAT, data->buf);

    data->buf->msg_qbytes = (sizeof(queMsg_t) * 10);
    msgctl(data->msgid, IPC_SET, data->buf);
    msgctl(data->msgid, IPC_STAT, data->buf);

    strcpy(data->message->message_text, "ping");
    data->message->message_type = 1;
    msgsnd(data->msgid, data->message, sizeof(queMsg_t), 0);

    pthread_t readThread;
    pthread_t timeoutThread;
    pthread_t writeThread;

    pthread_create(&writeThread, NULL, sysQueWrite, (void*)data);
    pthread_create(&readThread, NULL, sysQueRead, (void*)data);
    pthread_create(&timeoutThread, NULL, sysQueTimeout, (void*)data);

    pthread_join(timeoutThread, NULL);
}

/**
 * @brief read from system queue, used as a thread, should not be called directly
 * 
 * @param arg thread data struct generated by sysQueInit
 * @return void* NULL
 */
void* sysQueRead(void* arg){    
    if(PROSESS_PAIR_DEBUG)printf("Starting sysQueRead\n");
    queMsgData_t* data = (queMsgData_t*)arg;
    while (!data->sysQueMaster){
        queMsgData_t* temp = (queMsgData_t*)malloc(sizeof(queMsgData_t));
        temp->message = (queMsg_t*)malloc(sizeof(queMsg_t));
        temp->buf = (struct msqid_ds*)malloc(sizeof(struct msqid_ds));
        msgrcv(data->msgid, temp->message, sizeof(queMsg_t), 1, 0);
        msgctl(data->msgid, IPC_STAT, temp->buf);
        pthread_mutex_lock(data->queOutputMutex);
        data->message = temp->message;
        data->buf = temp->buf;
        pthread_mutex_unlock(data->queOutputMutex);
        free(temp);
        time_t currentTime;
        time(&currentTime);
        if(PROSESS_PAIR_DEBUG)printf("%s -> Received: %s\n",ctime(&currentTime), data->message->message_text);
        if(PROSESS_PAIR_DEBUG)printf("msg_qnum: %ld\n", data->buf->msg_qnum);
        time_t msgTime = data->buf->msg_stime;
        if(PROSESS_PAIR_DEBUG)printf("msg_stime: %s\n", ctime(&msgTime));
        usleep(100000);
    }
    return NULL;
}

/**
 * @brief write to system queue, used as a thread, should not be called directly
 * 
 * @param arg thread data struct generated by sysQueInit
 * @return void* NULL
 */
void* sysQueWrite(void* arg){
    queMsgData_t* data = (queMsgData_t*)arg;
    while(!data->sysQueMaster){
        usleep(100000);
    }
    if(PROSESS_PAIR_DEBUG)printf("Starting sysQueWrite\n");
    queMsg_t* message = (queMsg_t*)malloc(sizeof(queMsg_t));
    while (true){
        strcpy(message->message_text, "ping");
        message->message_type = 1;
        msgsnd(data->msgid, message, sizeof(queMsg_t), 0);
        usleep(100000);
        if(PROSESS_PAIR_DEBUG)printf("Sent: %s\n", message->message_text);
    }
    return NULL;
}

/**
 * @brief timeout for system queue, used as a thread, should not be called directly
 * 
 * @param arg thread data struct generated by sysQueInit
 * @return void* NULL
 */
void* sysQueTimeout(void* arg){
    if(PROSESS_PAIR_DEBUG)printf("Starting sysQueTimeout\n");
    queMsgData_t* data = (queMsgData_t*)arg;
    while (true){
        //printf("checking for timeoutSysQue\n");
        pthread_mutex_lock(data->queOutputMutex);
        time_t msgTime = data->buf->msg_stime;
        pthread_mutex_unlock(data->queOutputMutex);
        time_t currentTime;
        time(&currentTime);
        //printf("msg time is: %s \n", ctime(&msgTime));
        //printf("sys time is: %s \n\n", ctime(&currentTime));
        if(currentTime - msgTime > data->sysQueTimeout){
            if(PROSESS_PAIR_DEBUG){
                printf("msg time is: %s \n", ctime(&msgTime));
                printf("sys time is: %s \n\n", ctime(&currentTime));
                printf("Ping not received for %d seconds\n", data->sysQueTimeout);
                printf("Making master and spawning new slave\n");
            }
            makeMaster(data);
            return NULL;
        }
        usleep(20000);
    }
    return NULL;
}

/**
 * @brief crash the system, used for testing, call this function to crash the system, call it as a thread
 * 
 * @param arg NULL
 * @return void* NULL
 */
void* crashSystem(void* arg){
    sleep(15);
    if(PROSESS_PAIR_DEBUG)printf("Crashing system\n");
    exit(0);
    return NULL;
}

/**
 * @brief make this process the sysQue master, should not be called directly, call sysQueInit instead
 * 
 * @param data thread data struct generated by sysQueInit
 */
void makeMaster(queMsgData_t* data){

    extern char * program_invocation_name;
    char* command = (char*)malloc(100);
    strcpy(command, "gnome-terminal -- ");
    strcat(command, program_invocation_name);
    if(PROSESS_PAIR_DEBUG)printf("command: %s\n", command);
    if(PROSESS_PAIR_DEBUG)printf("Making master\n");
    data->sysQueMaster = true;
    system(command);

}
